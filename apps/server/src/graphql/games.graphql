# import Player from "players.graphql"

type Game {
  """
  lobby properties
  """
  id: ID!
  created: Float!
  players: [Player]!
  messages: [Message]
  """
  game properties
  """
  kind: String
  locales: ItemLocales
  meshes: [Mesh]
  cameras: [CameraPosition]
  hands: [Hand]
  preferences: [PlayerPreference]
  rulesBookPageCount: Int
  availableSeats: Int
  zoomSpec: ZoomSpec
  tableSpec: TableSpec
}

type DetailableState {
  frontImage: String!
  backImage: String
}

type FlippableState {
  isFlipped: Boolean
  duration: Int
}

type RotableState {
  angle: Float
  duration: Int
}

type Point {
  x: Float
  y: Float
  z: Float
}

type MovableState {
  duration: Int
  snapDistance: Float
  kind: String
  partCenters: [Point]
}

type StackableState {
  stackIds: [String]
  duration: Int
  extent: Float
  priority: Float
  kinds: [String]
}

type AnchorableState {
  anchors: [Anchor]
  duration: Int
}

type DrawableState {
  unflipOnPick: Boolean
  flipOnPlay: Boolean
  duration: Int
}

type LockableState {
  isLocked: Boolean
}

type QuantifiableState {
  quantity: Int
  duration: Int
  extent: Float
  priority: Float
  kinds: [String]
}

type RandomizableState {
  face: Int
  duration: Int
  canBeSet: Boolean
}

type Anchor {
  id: ID
  x: Float
  y: Float
  z: Float
  width: Float
  height: Float
  depth: Float
  diameter: Float
  extent: Float
  priority: Float
  kinds: [String]
  snappedId: ID
  playerId: ID
  ignoreParts: Boolean
}

type Mesh {
  id: ID!
  texture: String!
  faceUV: [[Float]]
  shape: Shape
  x: Float
  y: Float
  z: Float
  detailable: DetailableState
  movable: MovableState
  flippable: FlippableState
  rotable: RotableState
  anchorable: AnchorableState
  stackable: StackableState
  drawable: DrawableState
  lockable: LockableState
  quantifiable: QuantifiableState
  randomizable: RandomizableState
  """
  boxes, cards, prisms, rounded tokens and rounded tiles
  """
  height: Float
  """
  boxes, cards, prisms, and rounded tiles
  """
  width: Float
  """
  boxes, cards, and rounded tiles
  """
  depth: Float
  """
  round tokens and dice
  """
  diameter: Float
  """
  rounded tiles
  """
  borderRadius: Float
  """
  custom
  """
  file: String
  """
  prisms
  """
  edges: Float
  prismRotation: Float
  """
  dice
  """
  faces: Int
}

enum Shape {
  box
  card
  custom
  die
  prism
  roundedTile
  roundToken
}

type Message {
  playerId: ID!
  text: String!
  time: Float!
}

type CameraPosition {
  playerId: ID!
  index: Float!
  target: [Float]!
  alpha: Float!
  beta: Float!
  elevation: Float!
  hash: String!
}

type Hand {
  playerId: ID!
  meshes: [Mesh]!
}

type PlayerPreference {
  playerId: ID!
  color: String
}

type ZoomSpec {
  min: Float
  max: Float
  hand: Float
}

type TableSpec {
  width: Float
  height: Float
  texture: String
}

input GameInput {
  id: ID!
  meshes: [MeshInput]
  messages: [MessageInput]
  cameras: [CameraPositionInput]
  hands: [HandInput]
}

input DetailableStateInput {
  frontImage: String!
  backImage: String
}

input FlippableStateInput {
  isFlipped: Boolean
  duration: Int
}

input RotableStateInput {
  angle: Float
  duration: Int
}

input PointInput {
  x: Float
  y: Float
  z: Float
}

input MovableStateInput {
  duration: Int
  snapDistance: Float
  kind: String
  partCenters: [PointInput]
}

input StackableStateInput {
  stackIds: [String]
  duration: Int
  extent: Float
  priority: Float
  kinds: [String]
}

input AnchorableStateInput {
  anchors: [AnchorInput]
  duration: Int
}

input DrawableStateInput {
  unflipOnPick: Boolean
  flipOnPlay: Boolean
  duration: Int
}

input LockableStateInput {
  isLocked: Boolean
}

input QuantifiableStateInput {
  quantity: Int
  duration: Int
  extent: Float
  priority: Float
  kinds: [String]
}

input RandomizableStateInput {
  face: Int
  duration: Int
  canBeSet: Boolean
}

input AnchorInput {
  id: ID
  x: Float
  y: Float
  z: Float
  width: Float
  height: Float
  depth: Float
  diameter: Float
  extent: Float
  priority: Float
  kinds: [String]
  snappedId: ID
  playerId: ID
  ignoreParts: Boolean
}

input MeshInput {
  id: ID!
  texture: String!
  faceUV: [[Float]]
  shape: Shape
  x: Float
  y: Float
  z: Float
  detailable: DetailableStateInput
  movable: MovableStateInput
  flippable: FlippableStateInput
  rotable: RotableStateInput
  anchorable: AnchorableStateInput
  stackable: StackableStateInput
  drawable: DrawableStateInput
  lockable: LockableStateInput
  quantifiable: QuantifiableStateInput
  randomizable: RandomizableStateInput
  """
  boxes, cards, prisms, rounded tokens and rounded tiles
  """
  height: Float
  """
  boxes, cards, prisms, and rounded tiles
  """
  width: Float
  """
  boxes, cards, and rounded tiles
  """
  depth: Float
  """
  round tokens and dice
  """
  diameter: Float
  """
  rounded tiles
  """
  borderRadius: Float
  """
  custom
  """
  file: String
  """
  prisms
  """
  edges: Float
  prismRotation: Float
  """
  dice
  """
  faces: Int
}

input MessageInput {
  playerId: ID!
  text: String!
  time: Float!
}

input CameraPositionInput {
  playerId: ID!
  index: Float!
  target: [Float]!
  alpha: Float!
  beta: Float!
  elevation: Float!
  hash: String!
}

input HandInput {
  playerId: ID!
  meshes: [MeshInput]!
}

type GameParameters {
  schemaString: String!
  error: String
  id: ID!
  kind: String
  locales: ItemLocales
  players: [Player]!
  preferences: [PlayerPreference]
  rulesBookPageCount: Int
  availableSeats: Int
}

union GameOrParameters = Game | GameParameters

extend type Query {
  listGames: [Game]
}

extend type Mutation {
  createGame(kind: String): Game
  joinGame(gameId: ID!, parameters: String): GameOrParameters
  promoteGame(gameId: ID!, kind: String!): GameOrParameters
  saveGame(game: GameInput!): Game
  deleteGame(gameId: ID!): Game
  invite(gameId: ID!, playerIds: [ID!]!): Game
}

extend type Subscription {
  receiveGameListUpdates: [Game]
  receiveGameUpdates(gameId: ID!): Game
}
