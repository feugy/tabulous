type GamePlayer {
  id: ID!
  username: String!
  currentGameId: ID
  avatar: String
  isGuest: Boolean
  isOwner: Boolean
}

type Game {
  """
  lobby properties
  """
  id: ID!
  created: Float!
  players: [GamePlayer]!
  messages: [Message]
  """
  game properties
  """
  kind: String
  engineScript: String
  locales: ItemLocales
  meshes: [Mesh]
  cameras: [CameraPosition]
  hands: [Hand]
  preferences: [PlayerPreference]
  rulesBookPageCount: Int
  availableSeats: Int
  zoomSpec: ZoomSpec
  tableSpec: TableSpec
  colors: ColorSpec
  actions: ActionSpec
  history: [HistoryRecord]
}

type DetailableState {
  frontImage: String!
  backImage: String
}

type FlippableState {
  isFlipped: Boolean
  duration: Int
}

type RotableState {
  angle: Float
  duration: Int
}

type Point {
  x: Float
  y: Float
  z: Float
}

type MovableState {
  duration: Int
  snapDistance: Float
  kind: String
  partCenters: [Point]
}

type StackableState {
  stackIds: [String]
  duration: Int
  extent: Float
  priority: Float
  kinds: [String]
  angle: Float
}

type AnchorableState {
  anchors: [Anchor]
  duration: Int
}

type DrawableState {
  unflipOnPick: Boolean
  flipOnPlay: Boolean
  angleOnPick: Float
  duration: Int
}

type LockableState {
  isLocked: Boolean
}

type QuantifiableState {
  quantity: Int
  duration: Int
  extent: Float
  priority: Float
  kinds: [String]
}

type RandomizableState {
  face: Int
  duration: Int
  canBeSet: Boolean
}

type Anchor {
  id: ID
  x: Float
  y: Float
  z: Float
  width: Float
  height: Float
  depth: Float
  diameter: Float
  extent: Float
  priority: Float
  kinds: [String]
  snappedId: ID
  playerId: ID
  ignoreParts: Boolean
  angle: Float
  flip: Boolean
}

type Mesh {
  id: ID!
  texture: String!
  faceUV: [[Float]]
  shape: Shape!
  x: Float
  y: Float
  z: Float
  transform: InitialTransform
  detailable: DetailableState
  movable: MovableState
  flippable: FlippableState
  rotable: RotableState
  anchorable: AnchorableState
  stackable: StackableState
  drawable: DrawableState
  lockable: LockableState
  quantifiable: QuantifiableState
  randomizable: RandomizableState
  """
  boxes, cards, prisms, rounded tokens and rounded tiles
  """
  height: Float
  """
  boxes, cards, prisms, and rounded tiles
  """
  width: Float
  """
  boxes, cards, and rounded tiles
  """
  depth: Float
  """
  round tokens and dice
  """
  diameter: Float
  """
  rounded tiles
  """
  borderRadius: Float
  """
  custom
  """
  file: String
  """
  prisms
  """
  edges: Float
  """
  dice
  """
  faces: Int
}

enum Shape {
  box
  card
  custom
  die
  prism
  roundedTile
  roundToken
}

type InitialTransform {
  yaw: Float
  pitch: Float
  roll: Float
  scaleX: Float
  scaleY: Float
  scaleZ: Float
}

type Message {
  playerId: ID!
  text: String!
  time: Float!
}

type CameraPosition {
  playerId: ID!
  index: Float!
  target: [Float]!
  alpha: Float!
  beta: Float!
  elevation: Float!
  hash: String!
}

type Hand {
  playerId: ID!
  meshes: [Mesh]!
}

type PlayerPreference {
  playerId: ID!
  color: String
  angle: Float
}

type ZoomSpec {
  min: Float
  max: Float
  hand: Float
}

type TableSpec {
  width: Float
  height: Float
  texture: String
}

type ColorSpec {
  base: String
  primary: String
  secondary: String
}

enum ActionName {
  decrement
  detail
  draw
  flip
  flipAll
  increment
  play
  pop
  push
  random
  reorder
  rotate
  setFace
  snap
  toggleLock
  unsnap
  unsnapAll
}

type ActionSpec {
  button1: [ActionName]
  button2: [ActionName]
}

interface HistoryRecord {
  time: Float!
  meshId: ID!
  playerId: ID!
  duration: Int
  fromHand: Boolean
}

type PlayerAction implements HistoryRecord {
  time: Float!
  meshId: ID!
  playerId: ID!
  fn: String!
  argsStr: String
  revertStr: String
  duration: Int
  fromHand: Boolean
}

type PlayerMove implements HistoryRecord {
  time: Float!
  meshId: ID!
  playerId: ID!
  pos: [Float]!
  prev: [Float]!
  duration: Int
  fromHand: Boolean
}

input GameInput {
  id: ID!
  meshes: [MeshInput]
  messages: [MessageInput]
  cameras: [CameraPositionInput]
  hands: [HandInput]
  history: [HistoryRecordInput]
}

input DetailableStateInput {
  frontImage: String!
  backImage: String
}

input FlippableStateInput {
  isFlipped: Boolean
  duration: Int
}

input RotableStateInput {
  angle: Float
  duration: Int
}

input PointInput {
  x: Float
  y: Float
  z: Float
}

input MovableStateInput {
  duration: Int
  snapDistance: Float
  kind: String
  partCenters: [PointInput]
}

input StackableStateInput {
  stackIds: [String]
  duration: Int
  extent: Float
  priority: Float
  kinds: [String]
  angle: Float
}

input AnchorableStateInput {
  anchors: [AnchorInput]
  duration: Int
}

input DrawableStateInput {
  unflipOnPick: Boolean
  flipOnPlay: Boolean
  angleOnPick: Float
  duration: Int
}

input LockableStateInput {
  isLocked: Boolean
}

input QuantifiableStateInput {
  quantity: Int
  duration: Int
  extent: Float
  priority: Float
  kinds: [String]
}

input RandomizableStateInput {
  face: Int
  duration: Int
  canBeSet: Boolean
}

input AnchorInput {
  id: ID
  x: Float
  y: Float
  z: Float
  width: Float
  height: Float
  depth: Float
  diameter: Float
  extent: Float
  priority: Float
  kinds: [String]
  snappedId: ID
  playerId: ID
  ignoreParts: Boolean
  angle: Float
  flip: Boolean
}

input MeshInput {
  id: ID!
  texture: String!
  faceUV: [[Float]]
  shape: Shape
  x: Float
  y: Float
  z: Float
  detailable: DetailableStateInput
  movable: MovableStateInput
  flippable: FlippableStateInput
  rotable: RotableStateInput
  anchorable: AnchorableStateInput
  stackable: StackableStateInput
  drawable: DrawableStateInput
  lockable: LockableStateInput
  quantifiable: QuantifiableStateInput
  randomizable: RandomizableStateInput
  transform: InitialTransformInput
  """
  boxes, cards, prisms, rounded tokens and rounded tiles
  """
  height: Float
  """
  boxes, cards, prisms, and rounded tiles
  """
  width: Float
  """
  boxes, cards, and rounded tiles
  """
  depth: Float
  """
  round tokens and dice
  """
  diameter: Float
  """
  rounded tiles
  """
  borderRadius: Float
  """
  custom
  """
  file: String
  """
  prisms
  """
  edges: Float
  """
  dice
  """
  faces: Int
}

input InitialTransformInput {
  yaw: Float
  pitch: Float
  roll: Float
  scaleX: Float
  scaleY: Float
  scaleZ: Float
}

input MessageInput {
  playerId: ID!
  text: String!
  time: Float!
}

input CameraPositionInput {
  playerId: ID!
  index: Float!
  target: [Float]!
  alpha: Float!
  beta: Float!
  elevation: Float!
  hash: String!
}

input HandInput {
  playerId: ID!
  meshes: [MeshInput]!
}

input HistoryRecordInput {
  time: Float!
  meshId: ID!
  playerId: ID!
  fn: String
  argsStr: String
  revertStr: String
  pos: [Float]
  prev: [Float]
  duration: Int
  fromHand: Boolean
}

type GameParameters {
  schemaString: String!
  error: String
  id: ID!
  kind: String
  locales: ItemLocales
  players: [GamePlayer]!
  preferences: [PlayerPreference]
  rulesBookPageCount: Int
  availableSeats: Int
  colors: ColorSpec
}

union GameOrParameters = Game | GameParameters

extend type Query {
  listGames: [Game!]!
}

extend type Mutation {
  createGame(kind: String): Game!
  joinGame(gameId: ID!, parameters: String): GameOrParameters
  promoteGame(gameId: ID!, kind: String!): GameOrParameters
  saveGame(game: GameInput!): Game
  deleteGame(gameId: ID!): Game
  invite(gameId: ID!, playerIds: [ID!]!): Game
  kick(gameId: ID!, playerId: ID!): Game
}

extend type Subscription {
  receiveGameListUpdates: [Game!]!
  receiveGameUpdates(gameId: ID!): Game
}
