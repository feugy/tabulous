# import Player from "players.graphql"

type Game {
  id: ID!
  kind: String!
  created: Float!
  players: [Player]!
  meshes: [Mesh]!
  messages: [Message]
  cameras: [CameraPosition]
  hands: [Hand]
  rulesBookPageCount: Int
}

type DetailableState {
  frontImage: String!
  backImage: String
}

type FlippableState {
  isFlipped: Boolean
  duration: Int
}

type RotableState {
  angle: Float
  duration: Int
}

type MovableState {
  duration: Int
  snapDistance: Float
  kind: String
}

type StackableState {
  stackIds: [String]
  duration: Int
  extent: Float
  priority: Float
  kinds: [String]
}

type AnchorableState {
  anchors: [Anchor]
  duration: Int
}

type DrawableState {
  unflipOnPick: Boolean
  flipOnPlay: Boolean
  duration: Int
}

type Anchor {
  x: Float
  y: Float
  z: Float
  width: Float
  height: Float
  depth: Float
  priority: Float
  kinds: [String]
  snappedId: ID
}

type Mesh {
  id: ID!
  texture: String!
  faceUV: [[Float]]
  shape: Shape
  x: Float
  y: Float
  z: Float
  detailable: DetailableState
  movable: MovableState
  flippable: FlippableState
  rotable: RotableState
  anchorable: AnchorableState
  stackable: StackableState
  drawable: DrawableState
  """
  cards, rounded tokens and rounded tiles
  """
  height: Float
  """
  cards and rounded tiles
  """
  width: Float
  depth: Float
  """
  round tokens
  """
  diameter: Float
  """
  rounded tiles
  """
  borderRadius: Float
}

enum Shape {
  card
  roundedTile
  roundToken
}

type Message {
  playerId: ID!
  text: String!
  time: Float!
}

type CameraPosition {
  playerId: ID!
  index: Float!
  target: [Float]!
  alpha: Float!
  beta: Float!
  elevation: Float!
  hash: String!
}

type Hand {
  playerId: ID!
  meshes: [Mesh]!
}

input GameInput {
  id: ID!
  meshes: [MeshInput]
  messages: [MessageInput]
  cameras: [CameraPositionInput]
  hands: [HandInput]
}

input DetailableStateInput {
  frontImage: String!
  backImage: String
}

input FlippableStateInput {
  isFlipped: Boolean
  duration: Int
}

input RotableStateInput {
  angle: Float
  duration: Int
}

input MovableStateInput {
  duration: Int
  snapDistance: Float
  kind: String
}

input StackableStateInput {
  stackIds: [String]
  duration: Int
  extent: Float
  priority: Float
  kinds: [String]
}

input AnchorableStateInput {
  anchors: [AnchorInput]
  duration: Int
}

input DrawableStateInput {
  unflipOnPick: Boolean
  flipOnPlay: Boolean
  duration: Int
}

input AnchorInput {
  x: Float
  y: Float
  z: Float
  width: Float
  height: Float
  depth: Float
  priority: Float
  kinds: [String]
  snappedId: ID
}

input MeshInput {
  id: ID!
  texture: String!
  faceUV: [[Float]]
  shape: Shape
  x: Float
  y: Float
  z: Float
  detailable: DetailableStateInput
  movable: MovableStateInput
  flippable: FlippableStateInput
  rotable: RotableStateInput
  anchorable: AnchorableStateInput
  stackable: StackableStateInput
  drawable: DrawableStateInput
  """
  cards, rounded tokens and rounded tiles
  """
  height: Float
  """
  cards and rounded tiles
  """
  width: Float
  depth: Float
  """
  round tokens
  """
  diameter: Float
  """
  rounded tiles
  """
  borderRadius: Float
}

input MessageInput {
  playerId: ID!
  text: String!
  time: Float!
}

input CameraPositionInput {
  playerId: ID!
  index: Float!
  target: [Float]!
  alpha: Float!
  beta: Float!
  elevation: Float!
  hash: String!
}

input HandInput {
  playerId: ID!
  meshes: [MeshInput]!
}

extend type Query {
  loadGame(gameId: ID!): Game
}

extend type Mutation {
  createGame(kind: String!): Game
  saveGame(game: GameInput!): Game
  deleteGame(gameId: ID!): Game
  invite(gameId: ID!, playerId: ID!): Game
}

extend type Subscription {
  listGames: [Game]
}
